#' Evaluate metrics at multiple scales of aggregation
#'
#' @details
#' The grid blocks can be controlled by passing arguments to
#' [sf::st_make_grid()] via `...`. Some particularly useful arguments include:
#'
#' * `cellsize`: Target cellsize, expressed as the "diameter" (shortest
#' straight-line distance between opposing sides; two times the apothem)
#' of each block, in map units.
#' * `n`: The number of grid blocks in the x and y direction (columns, rows).
#' * `square`: A logical value indicating whether to create square (`TRUE`) or
#' hexagonal (`FALSE`) cells.
#'
#' If both `cellsize` and `n` are provided, then the number of blocks requested
#' by `n` of sizes specified by `cellsize` will be returned, likely not
#' lining up with the bounding box of `data`. If only `cellsize`
#' is provided, this function will return as many blocks of size
#' `cellsize` as fit inside the bounding box of `data`. If only `n` is provided,
#' then `cellsize` will be automatically adjusted to create the requested
#' number of cells.
#'
#' This function can be used for geographic or projected coordinate reference
#' systems and expect 2D data.
#'
#' @srrstats {SP1.0} Domain of applicability specified above.
#' @srrstats {SP1.1} Dimensional domain of applicability specified above.
#'
#' @srrstats {G2.7} This function relies on yardstick and dplyr and therefore only handles data.frame and vector input.
#' @srrstats {G2.10} Column extraction is properly handled within yardstick.
#' @srrstats {G2.14} Any function may be passed to na_action
#' @srrstats {G2.14a} Any function may be passed to na_action
#' @srrstats {G2.14b} Any function may be passed to na_action
#' @srrstats {G2.14c} Any function may be passed to na_action
#' @srrstats {G2.15} Any function may be passed to na_action
#' @srrstats {G2.16} Any function may be passed to na_action
#'
#' @srrstats {SP2.6} Input type requirements are documented.
#' @param data A point geometry `sf` object containing the columns specified by
#' the truth and estimate arguments.
#' @inheritParams yardstick::rmse
#' @param metrics Either a [yardstick::metric_set()] object, or a list of
#' functions which will be used to construct a [yardstick::metric_set()] object
#' specifying the performance metrics to evaluate at each scale.
#' @param grids Optionally, a list of pre-computed `sf` or `sfc` objects
#' specifying polygon boundaries to use for assessments.
#' @param ... Arguments passed to [sf::st_make_grid()].
#' **You almost certainly should provide these arguments as lists.**
#' For instance, passing `n = list(c(1, 2))` will create a single 1x2 grid;
#' passing `n = c(1, 2)` will create a 1x1 grid _and_ a 2x2 grid.
#' @param aggregation_function The function to use to aggregate predictions and
#' true values at various scales, by default [mean()]. You can pass any function
#' which takes a single vector and returns a scalar.
#' @param autoexpand_grid Boolean: if `data` is in geographic coordinates and
#' `grids` aren't provided, the grids generated by [sf::st_make_grid()] may not
#' contain all observations. If `TRUE`, this function will automatically expand
#' generated grids by a tiny factor to attempt to capture all observations.
#' @inheritParams ww_area_of_applicability
#'
#' @srrstats {SP4.0} Outputs are in a unique format
#' @srrstats {SP4.0b} Outputs are in a unique format
#' @srrstats {SP4.2} Type and class of return values are documented
#' @return A tibble with six columns: `.metric`, with the name
#' of the metric that the row describes; `.estimator`, with the name of the
#' estimator used, `.estimate`, with the output of the metric function;
#' `.grid_args`, with the arguments passed to [sf::st_make_grid()] via `...`
#' (if any), `.grid`, containing the grids used to aggregate predictions,
#' and `.notes`, which will indicate any observations which were not used in
#' a given assessment.
#'
#' @examplesIf rlang::is_installed("modeldata")
#' data(ames, package = "modeldata")
#' ames_sf <- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
#' ames_model <- lm(Sale_Price ~ Lot_Area, data = ames_sf)
#' ames_sf$predictions <- predict(ames_model, ames_sf)
#'
#' ww_multi_scale(
#'   ames_sf,
#'   Sale_Price,
#'   predictions,
#'   n = list(
#'     c(10, 10),
#'     c(1, 1)
#'   ),
#'   square = FALSE
#' )
#'
#' # or, mostly equivalently
#' # (there will be a slight difference due to `autoexpand_grid = TRUE`)
#' grids <- list(
#'   sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
#'   sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
#' )
#' ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)
#'
#' @srrstats {G1.0} Reference for these methods:
#' @references
#' Riemann, R., Wilson, B. T., Lister, A., and Parks, S. (2010). "An effective
#' assessment protocol for continuous geospatial datasets of forest
#' characteristics using USFS Forest Inventory and Analysis (FIA) data."
#' Remote Sensing of Environment 114(10), pp 2337-2352,
#' doi: 10.1016/j.rse.2010.05.010 .
#'
#' @export
ww_multi_scale <- function(
    data,
    truth,
    estimate,
    metrics = list(yardstick::rmse, yardstick::mae),
    grids = NULL,
    ...,
    na_action = na.fail,
    aggregation_function = mean,
    autoexpand_grid = TRUE
) {
  # Silence NSE-related NOTE in R CMD check
  .truth <- .estimate <- NULL

  #' @srrstats {SP2.0} Checking input data for spatial objects
  #' @srrstats {SP2.0b} Will error on non-2d objects
  #' @srrstats {SP2.7} Validating inputs
  #' @srrstats {SP2.8} Pre-processing inputs
  #' @srrstats {SP2.9} Relevant attributes are preserved
  if (!(inherits(data, "sf") || inherits(data, "sfc"))) {
    rlang::abort(
      "`data` must be an `sf` or `sfc` object."
    )
  }

  #' @srrstats {G2.13} Checking inputs prior to calculations
  if (nrow(data) == 0) {
    rlang::abort(
      "0 rows were passed as training data."
    )
  }

  geom_type <- unique(sf::st_geometry_type(data))
  if (!(length(geom_type) == 1 && geom_type == "POINT")) {
    rlang::abort(
      c(
        "ww_multi_scale is currently only implemented for point geometries.",
        i = "Consider casting your data to points."
      )
    )
  }

  #' @srrstats {G2.0} Checking univariate inputs
  #' @srrstats {G2.2} Restricting multivariate input
  #' @srrstats {G2.13} Checking inputs prior to calculations
  if (length(na_action) != 1) {
    rlang::abort("Only one value can be passed to `na_action`.")
  }

  #' @srrstats {G2.4} Accepting various input types
  if (inherits(metrics, "metric")) metrics <- list(metrics)
  if (!inherits(metrics, "metric_set")) {
    metrics <- do.call(yardstick::metric_set, metrics)
  }

  truth_var <- tidyselect::eval_select(rlang::expr({{ truth }}), data)
  estimate_var <- tidyselect::eval_select(rlang::expr({{ estimate }}), data)

  if (!is.numeric(data[[truth_var]])) {
    rlang::abort("`truth` must be numeric.")
  }

  if (!is.numeric(data[[estimate_var]])) {
    rlang::abort("`estimate` must be numeric.")
  }

  data[[truth_var]] <- check_for_missing(
    data[[truth_var]],
    na_action,
    "`truth`",
    glue::glue("('{names(truth_var)}')")
  )

  data[[estimate_var]] <- check_for_missing(
    data[[estimate_var]],
    na_action,
    "`estimate`",
    glue::glue("('{names(estimate_var)}')")
  )

  if (missing(grids)) {
    grid_args <- rlang::list2(...)
    grid_args <- tibble::as_tibble(do.call(cbind, grid_args))

    grid_box <- sf::st_bbox(data)
    if (is_longlat(data) && autoexpand_grid) {
      # cf https://github.com/ropensci/stplanr/pull/467
      # basically: spherical geometry means sometimes the straight line of the
      # grid will exclude points within the bounding box
      #
      # so here we'll expand our boundary by a small bit in order to always contain our
      # points within the grid
      grid_box <- expand_grid(grid_box)
    }

    grids <- apply(
      grid_args,
      1,
      function(g_args) {
        do.call(
          sf::st_make_grid,
          c(g_args, x = list(grid_box))
        )
      }
    )
  }

  if (!is.na(sf::st_crs(data))) {
    grids <- purrr::map(grids, sf::st_transform, sf::st_crs(data))
  }

  grid_intersections <- purrr::map(
    grids,
    function(grid) {
      out <- sf::st_intersects(grid, data)
      out[purrr::map_lgl(out, function(x) !identical(x, integer(0)))]
    }
  )

  .notes <- purrr::map(
    grid_intersections,
    function(idx) {
      missing <- setdiff(seq_len(nrow(data)), unlist(idx))

      note <- character(0)

      if (length(missing) > 0) {
        note <- "Some observations were not within any grid cell, and as such were not used in any assessments. Their row numbers are in the `missing_indices` column."
        missing <- list(missing)
      } else {
        missing <- list()
      }

      tibble::tibble(
        note = note,
        missing_indices = missing
      )
    }
  )

  if (any(purrr::map_lgl(.notes, function(x) nrow(x) > 0))) {
    rlang::warn(
      c(
        "Some observations were not within any grid cell, and as such were not used in any assessments.",
        i = "See the `.notes` column for details."
      )
    )
  }

  grid_intersections <- purrr::map(
    grid_intersections,
    function(idx_list) {
      out <- purrr::map_dfr(
        idx_list,
        function(idx) dplyr::summarise(
          data[idx, , drop = FALSE],
          .truth = rlang::exec(aggregation_function, {{ truth }}),
          .estimate = rlang::exec(aggregation_function, {{ estimate }}),
          .groups = "keep"
        )
      )

      if (dplyr::is_grouped_df(data)) {
        dplyr::group_by(out, !!! dplyr::groups(data))
      } else {
        out
      }
    }
  )

  if (!exists("grid_args")) {
    grid_args <- tibble::tibble()
    grid_arg_idx <- 0
  } else {
    grid_arg_idx <- seq_len(nrow(grid_args))
  }

  purrr::pmap_dfr(
    list(
      dat = grid_intersections,
      grid = grids,
      grid_arg = grid_arg_idx,
      .notes = .notes
    ),
    function(dat, grid, grid_arg, .notes) {
      out <- metrics(dat, .truth, .estimate)
      out[attr(out, "sf_column")] <- NULL
      out$.grid_args <- list(grid_args[grid_arg, ])
      out$.grid <- list(
        sf::st_join(
          sf::st_as_sf(grid),
          dat,
          sf::st_contains
        )
      )
      out$.notes <- list(.notes)
      out
    }
  )
}


#' Expand geographic bounding boxes slightly
#'
#' Because we're drawing straight lines on spheres when working with geographic
#' coordinates, it's entirely possible to have points within a bounding box but
#' outside of the straight lines between the corners. As this is almost never
#' expected, this function adds a tiny fudge factor to bounding boxes in order
#' to "catch" points.
#'
#' @param grid_box The output from [sf::st_bbox()]
#' @param expansion The expansion factor: what fraction should each coordinate
#' be adjusted by?
#'
#' @return A very slightly buffered bounding box
#'
#' @references
#' https://github.com/ropensci/stplanr/pull/467
#'
#' @noRd
expand_grid <- function(grid_box, expansion = 0.00001) {
  grid_box[1] <- grid_box[1] - abs(grid_box[1] * expansion)
  grid_box[2] <- grid_box[2] - abs(grid_box[2] * expansion)
  grid_box[3] <- grid_box[3] + abs(grid_box[3] * expansion)
  grid_box[4] <- grid_box[4] + abs(grid_box[4] * expansion)
  grid_box
}

#' Check if an sf object is in geographic coordinates
#'
#' This function adjusts [sf::st_is_longlat()] so that data without a CRS,
#' such as simulated data on arbitrary grids, is treated as non-geographic.
#'
#' @inheritParams sf::st_is_longlat
#'
#' @noRd
is_longlat <- function(x) {
  !(sf::st_crs(x) == sf::NA_crs_) && sf::st_is_longlat(x)
}

