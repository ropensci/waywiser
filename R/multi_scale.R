#' Evaluate metrics at multiple scales of aggregation
#'
#' @details
#' The grid blocks can be controlled by passing arguments to
#' [sf::st_make_grid()] via `...`. Some particularly useful arguments include:
#'
#' * `cellsize`: Target cellsize, expressed as the "diameter" (shortest
#' straight-line distance between opposing sides; two times the apothem)
#' of each block, in map units.
#' * `n`: The number of grid blocks in the x and y direction (columns, rows).
#' * `square`: A logical value indicating whether to create square (`TRUE`) or
#' hexagonal (`FALSE`) cells.
#'
#' If both `cellsize` and `n` are provided, then the number of blocks requested
#' by `n` of sizes specified by `cellsize` will be returned, likely not
#' lining up with the bounding box of `data`. If only `cellsize`
#' is provided, this function will return as many blocks of size
#' `cellsize` as fit inside the bounding box of `data`. If only `n` is provided,
#' then `cellsize` will be automatically adjusted to create the requested
#' number of cells.
#'
#' @param data A point geometry `sf` object containing the columns specified by
#' the truth and estimate arguments.
#' @inheritParams yardstick::rmse
#' @param metrics Either a [yardstick::metric_set()] object, or a list of
#' functions which will be used to construct a [yardstick::metric_set()] object
#' specifying the performance metrics to evaluate at each scale.
#' @param grids Optionally, a list of pre-computed `sf` or `sfc` objects
#' specifying polygon boundaries to use for assessments.
#' @param ... Arguments passed to [sf::st_make_grid()].
#' **You almost certainly should provide these arguments as lists.**
#' For instance, passing `n = list(c(1, 2))` will create a single 1x2 grid;
#' passing `n = c(1, 2)` will create a 1x1 grid _and_ a 2x2 grid.
#' @param aggregation_function The function to use to aggregate predictions and
#' true values at various scales, by default [mean()]. You can pass any function
#' which takes a single vector and returns a scalar.
#' @param autoexpand_grid Boolean: if `data` is in geographic coordinates and
#' `grids` aren't provided, the grids generated by [sf::st_make_grid()] may not
#' contain all observations. If `TRUE`, this function will automatically expand
#' generated grids by a tiny factor to attempt to capture all observations.
#'
#' @return A tibble with six columns: `.metric`, with the name
#' of the metric that the row describes; `.estimator`, with the name of the
#' estimator used, `.estimate`, with the output of the metric function;
#' `.grid_args`, with the arguments passed to [sf::st_make_grid()] via `...`
#' (if any), `.grid`, containing the grids used to aggregate predictions,
#' and `.notes`, which will indicate any observations which were not used in
#' a given assessment.
#'
#' @examplesIf rlang::is_installed("modeldata")
#' data(ames, package = "modeldata")
#' ames_sf <- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
#' ames_model <- lm(Sale_Price ~ Lot_Area, data = ames_sf)
#' ames_sf$predictions <- predict(ames_model, ames_sf)
#'
#' ww_multi_scale(
#'   ames_sf,
#'   Sale_Price,
#'   predictions,
#'   n = list(
#'     c(20, 20),
#'     c(10, 10),
#'     c(1, 1)
#'   ),
#'   square = FALSE
#' )
#'
#' # or, mostly equivalently
#' # (there will be a slight difference due to `autoexpand_grid = TRUE`)
#' grids <- list(
#'   sf::st_make_grid(ames_sf, n = c(20, 20), square = FALSE),
#'   sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
#'   sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
#' )
#' ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)
#'
#' @export
ww_multi_scale <- function(
    data,
    truth,
    estimate,
    metrics = list(yardstick::rmse, yardstick::mae),
    grids = NULL,
    ...,
    aggregation_function = mean,
    autoexpand_grid = TRUE
) {
  .truth <- .estimate <- NULL

  geom_type <- unique(sf::st_geometry_type(data))
  if (!(length(geom_type) == 1 && geom_type == "POINT")) {
    rlang::abort(
      c(
        "ww_multi_scale is currently only implemented for point geometries.",
        i = "Consider casting your data to points."
      )
    )
  }

  if (inherits(metrics, "metric")) metrics <- list(metrics)

  if (!inherits(metrics, "metric_set")) {
    metrics <- do.call(yardstick::metric_set, metrics)
  }

  if (missing(grids)) {
    grid_args <- rlang::list2(...)
    grid_args <- tibble::as_tibble(do.call(cbind, grid_args))

    grid_box <- sf::st_bbox(data)
    if (is_longlat(data) && autoexpand_grid) {
      # cf https://github.com/ropensci/stplanr/pull/467
      # basically: spherical geometry means sometimes the straight line of the
      # grid will exclude points within the bounding box
      #
      # so here we'll expand our boundary by a small bit in order to always contain our
      # points within the grid
      grid_box <- expand_grid(grid_box)
    }

    grids <- apply(
      grid_args,
      1,
      function(g_args) {
        do.call(
          sf::st_make_grid,
          c(g_args, x = list(grid_box))
        )
      }
    )
  }

  if (!is.na(sf::st_crs(data))) {
    grids <- purrr::map(grids, sf::st_transform, sf::st_crs(data))
  }

  grid_intersections <- purrr::map(
    grids,
    function(grid) {
      out <- sf::st_intersects(grid, data)
      out[purrr::map_lgl(out, function(x) !identical(x, integer(0)))]
    }
  )

  .notes <- purrr::map(
    grid_intersections,
    function(idx) {
      missing <- setdiff(seq_len(nrow(data)), unlist(idx))

      note <- character(0)

      if (length(missing) > 0) {
        note <- "Some observations were not within any grid cell, and as such were not used in any assessments. Their row numbers are in the `missing_indices` column."
        missing <- list(missing)
      } else {
        missing <- list()
      }

      tibble::tibble(
        note = note,
        missing_indices = missing
      )
    }
  )

  if (any(purrr::map_lgl(.notes, function(x) nrow(x) > 0))) {
    rlang::warn(
      c(
        "Some observations were not within any grid cell, and as such were not used in any assessments.",
        i = "See the `.notes` column for details."
      )
    )
  }

  grid_intersections <- purrr::map(
    grid_intersections,
    function(idx_list) {
      purrr::map_dfr(
        idx_list,
        function(idx) dplyr::summarise(
          data[idx, , drop = FALSE],
          .truth = rlang::exec(aggregation_function, {{ truth }}),
          .estimate = rlang::exec(aggregation_function, {{ estimate }})
        )
      )
    }
  )

  if (!exists("grid_args")) {
    grid_args <- tibble::tibble()
    grid_arg_idx <- 0
  } else {
    grid_arg_idx <- seq_len(nrow(grid_args))
  }

  purrr::pmap_dfr(
    list(
      dat = grid_intersections,
      grid = grids,
      grid_arg = grid_arg_idx,
      .notes = .notes
    ),
    function(dat, grid, grid_arg, .notes) {
      out <- metrics(dat, .truth, .estimate)
      out[attr(out, "sf_column")] <- NULL
      out$.grid_args <- list(grid_args[grid_arg, ])
      out$.grid <- list(
        sf::st_join(
          sf::st_as_sf(grid),
          dat,
          sf::st_contains
        )
      )
      out$.notes <- list(.notes)
      out
    }
  )
}

expand_grid <- function(grid_box, expansion = 0.00001) {
  grid_box[1] <- grid_box[1] - abs(grid_box[1] * expansion)
  grid_box[2] <- grid_box[2] - abs(grid_box[2] * expansion)
  grid_box[3] <- grid_box[3] + abs(grid_box[3] * expansion)
  grid_box[4] <- grid_box[4] + abs(grid_box[4] * expansion)
  grid_box
}

is_longlat <- function(x) {
  !(sf::st_crs(x) == sf::NA_crs_) && sf::st_is_longlat(x)
}

