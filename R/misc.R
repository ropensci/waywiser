#' Make 'nb' objects from sf objects
#'
#' These functions can be used for geographic or projected coordinate reference
#' systems and expect 2D data.
#'
#' @srrstats {SP1.0} Domain of applicability specified above.
#' @srrstats {SP1.1} Dimensional domain of applicability specified above.
#'
#' @details
#' When `nb = NULL`, the method used to create neighbors from `data` is
#' dependent on what geometry type `data` is:
#'
#' + If `nb = NULL` and `data` is a point geometry
#' (classes "sfc_POINT" or "sfc_MULTIPOINT") the "nb" object will be created
#' using [ww_make_point_neighbors()].
#' + If `nb = NULL` and `data` is a polygon geometry
#' (classes "sfc_POLYGON" or "sfc_MULTIPOLYGON") the "nb" object will be created
#' using [ww_make_polygon_neighbors()].
#' + If `nb = NULL` and `data` is any other geometry type, the "nb" object will
#' be created using the centroids of the data as points, with a warning.
#'
#' @srrstats {SP2.6} Input type requirements are documented.
#' @srrstats {SP3.0} Users are given total control over weights.
#' @srrstats {SP3.0a} Users are given total control over weights.
#' @srrstats {SP3.0b} Users are given total control over weights.
#' @srrstats {SP3.1} Users are given total control over weights.
#' @param ... Arguments passed to the neighbor-creating function.
#' @param data An sf object (of class "sf" or "sfc").
#' @param nb An object of class "nb" (in which case it will be returned
#' unchanged), or a function to create an object of class "nb" from `data` and
#' `...`, or `NULL`. See details.
#' @inheritParams rlang::abort
#'
#' @examples
#' ww_build_neighbors(guerry)
#'
#' @srrstats {SP4.0} Outputs are in a unique format
#' @srrstats {SP4.0b} Outputs are in a unique format
#' @srrstats {SP4.2} Type and class of return values are documented
#' @return An object of class "nb".
#'
#' @export
ww_build_neighbors <- function(data, nb = NULL, ..., call = rlang::caller_env()) {

  #' @srrstats {SP2.0} Checking input data for spatial objects
  #' @srrstats {SP2.0b} Will error on non-2d objects
  #' @srrstats {SP2.7} Validating inputs
  #' @srrstats {SP2.8} Pre-processing inputs
  #' @srrstats {SP2.9} Relevant attributes are preserved
  if (!(inherits(data, "sf") || inherits(data, "sfc"))) {
    rlang::abort(
      "`data` must be an `sf` or `sfc` object.",
      call = call
    )
  }

  data <- sf::st_geometry(data)

  type <- if (any(c("sfc_MULTIPOINT", "sfc_POINT") %in% class(data))) {
    "point"
  } else if (any(c("sfc_MULTIPOLYGON", "sfc_POLYGON") %in% class(data))) {
    "polygon"
  } else if (is.null(nb)) {
    rlang::warn(
      c(
        "Non-point or polygon geometry specified, calculating neighbors using sf::st_centroid()",
        "i" = "To avoid this, provide neighbors explicitly",
        "i" = "Or provide a neighbor-creating function"
      ),
      call = call
    )
    data <- sf::st_centroid(data)
    "point"
  }

  #' @srrstats {SP3.0} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0a} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0b} User arguments are passed to neighborhoods
  #' @srrstats {SP3.1} User arguments are passed to neighborhoods
  if (is.null(nb)) {
    nb <- switch(
      type,
      "point" = ww_make_point_neighbors(data, ...),
      "polygon" = ww_make_polygon_neighbors(data, ...)
    )
  }

  if (rlang::is_function(nb)) {
    nb <- do.call(nb, list(data, ...))
  }

  if (!inherits(nb, "nb")) {
    rlang::abort(
      "Couldn't figure out how to build an `nb` object from the provided arguments",
      call = call
    )
  }

  nb

}

#' Make 'nb' objects from point geometries
#'
#' This function uses [spdep::knearneigh()] and [spdep::knn2nb()] to
#' create a "nb" neighbors list.
#'
#' These functions can be used for geographic or projected coordinate reference
#' systems and expect 2D data.
#'
#' @srrstats {SP1.0} Domain of applicability specified above.
#' @srrstats {SP1.1} Dimensional domain of applicability specified above.
#'
#' @srrstats {SP2.6} Input type requirements are documented.
#' @srrstats {SP3.0} Users are given total control over weights.
#' @srrstats {SP3.0a} Users are given total control over weights.
#' @srrstats {SP3.0b} Users are given total control over weights.
#' @srrstats {SP3.1} Users are given total control over weights.
#' @param data An `sfc_POINT` or `sfc_MULTIPOINT` object.
#' @param k How many nearest neighbors to use in [spdep::knearneigh()].
#' @param sym Force the output neighbors list (from [spdep::knn2nb()]) to
#' symmetry.
#' @param ... Other arguments passed to [spdep::knearneigh()].
#'
#' @srrstats {SP4.0} Outputs are in a unique format
#' @srrstats {SP4.0b} Outputs are in a unique format
#' @srrstats {SP4.2} Type and class of return values are documented
#' @return An object of class "nb"
#'
#' @examples
#' ww_make_point_neighbors(ny_trees)
#'
#' @export
ww_make_point_neighbors <- function(data, k = 1, sym = FALSE, ...) {

  #' @srrstats {SP2.0} Checking input data for spatial objects
  #' @srrstats {SP2.0b} Will error on non-2d objects
  #' @srrstats {SP2.7} Validating inputs
  #' @srrstats {SP2.8} Pre-processing inputs
  #' @srrstats {SP2.9} Relevant attributes are preserved
  if (!(inherits(data, "sf") || inherits(data, "sfc"))) {
    rlang::abort(
      "`data` must be an `sf` or `sfc` object."
    )
  }

  #' @srrstats {G2.0} Checking input lengths
  #' @srrstats {G2.1} Checking input types
  #' @srrstats {G2.2} Prohibiting multivariate input
  if (length(k) > 1 || !rlang::is_integerish(k)) {
    #' @srrstats {G2.0a} Secondary documentation
    #' @srrstats {G2.1a} Secondary documentation
    rlang::abort(
      "`k` must be a single numeric integer."
    )
  }

  #' @srrstats {SP3.0} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0a} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0b} User arguments are passed to neighborhoods
  knn <- spdep::knearneigh(data, k, ...)
  spdep::knn2nb(knn, sym = sym)

}

#' Make 'nb' objects from polygon geometries
#'
#' This function is an extremely thin wrapper around [spdep::poly2nb()],
#' renamed to use the waywiser "ww" prefix.
#'
#' These functions can be used for geographic or projected coordinate reference
#' systems and expect 2D data.
#'
#' @srrstats {SP1.0} Domain of applicability specified above.
#' @srrstats {SP1.1} Dimensional domain of applicability specified above.
#'
#' @srrstats {SP2.6} Input type requirements are documented.
#' @srrstats {SP3.0} Users are given total control over weights.
#' @srrstats {SP3.0a} Users are given total control over weights.
#' @srrstats {SP3.0b} Users are given total control over weights.
#' @srrstats {SP3.1} Users are given total control over weights.
#' @param data An `sfc_POLYGON` or `sfc_MULTIPOLYGON` object.
#' @param ... Additional arguments passed to [spdep::poly2nb()].
#'
#' @srrstats {SP4.0} Outputs are in a unique format
#' @srrstats {SP4.0b} Outputs are in a unique format
#' @srrstats {SP4.2} Type and class of return values are documented
#' @return An object of class "nb"
#'
#' @examples
#' ww_make_polygon_neighbors(guerry)
#'
#' @export
ww_make_polygon_neighbors <- function(data, ...) {
  #' @srrstats {SP3.0} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0a} User arguments are passed to neighborhoods
  #' @srrstats {SP3.0b} User arguments are passed to neighborhoods
  #' @srrstats {SP3.1} User arguments are passed to neighborhoods
  spdep::poly2nb(data, ...)
}

#' Build "listw" objects of spatial weights
#'
#' These functions can be used for geographic or projected coordinate reference
#' systems and expect 2D data.
#'
#' @srrstats {SP1.0} Domain of applicability specified above.
#' @srrstats {SP1.1} Dimensional domain of applicability specified above.
#'
#' @srrstats {SP2.6} Input type requirements are documented.
#' @srrstats {SP3.0} Users are given total control over weights.
#' @srrstats {SP3.0a} Users are given total control over weights.
#' @srrstats {SP3.0b} Users are given total control over weights.
#' @srrstats {SP3.1} Users are given total control over weights.
#' @param x Either an sf object or a "nb" neighbors list object.
#' If an sf object, will be converted into a neighbors list via
#' [ww_build_neighbors()].
#' @param wt Either a "listw" object (which will be returned unchanged),
#' a function for creating a "listw" object from `x`, or `NULL`, in which case
#' weights will be constructed via [spdep::nb2listw()].
#' @param include_self Include each region itself in its own list of neighbors?
#' @param ... Arguments passed to the weight constructing function.
#'
#' @srrstats {SP4.0} Outputs are in a unique format
#' @srrstats {SP4.0b} Outputs are in a unique format
#' @srrstats {SP4.2} Type and class of return values are documented
#' @return A `listw` object.
#'
#' @examples
#' ww_build_weights(guerry)
#'
#' @export
ww_build_weights <- function(x, wt = NULL, include_self = FALSE, ...) {

  if (!inherits(x, "nb")) {
    x <- ww_build_neighbors(x, call = rlang::caller_env())
  }

  if (include_self) {
    if (!identical(attr(x, "self.included"), TRUE)) x <- spdep::include.self(x)
  }

  if (is.null(wt)) wt <- spdep::nb2listw(x, ...)

  if (rlang::is_function(wt)) {
    wt <- do.call(wt, list(x, ...))
  }

  if (!inherits(wt, "listw")) {
    rlang::abort(
      "Couldn't figure out how to build a `listw` object from the provided arguments",
      call = rlang::caller_env()
    )
  }

  wt

}

#' Run `na_action` against data, with useful error messages if needed
#'
#' @param dat A data.frame
#' @inheritParams rlang::abort
#' @inheritParams ww_area_of_applicability
#' @param where The name of the object that is being passed to `dat`
#' @param where_longer The name of the argument that the user would have passed `dat` to.
#'
#' @return `do.call(na_action, list(dat))`
#'
#' @srrstats {G1.4a} Internal function documentation
#'
#' @noRd
check_for_missing <- function(dat, na_action, where, where_longer, call = rlang::caller_env()) {

  #' @srrstats {G2.2} Asserting univariate input
  if (length(na_action) != 1) {
    rlang::abort(
      "Only one value can be passed to na_action."
    )
  }

  if (any(is.na(dat))) {
    #' @srrstats {G2.4} na_action can be character or function:
    tryCatch(
      #' @srrstats {G2.13} Checking for missing data
      #' @srrstats {G2.14} Any function may be passed to na_action
      #' @srrstats {G2.14a} Any function may be passed to na_action
      #' @srrstats {G2.14b} Any function may be passed to na_action
      #' @srrstats {G2.14c} Any function may be passed to na_action
      #' @srrstats {G2.15} Any function may be passed to na_action
      #' @srrstats {G2.16} Any function may be passed to na_action
      dat <- do.call(na_action, list(dat)),
      error = function(e) {
        rlang::abort(
          c(
            glue::glue("Missing values in {where} {where_longer}."),
            i = "Either process your data to fix the NA values or set `na_action`."
          ),
          call = call
        )
      }
    )
  }
  dat
}

