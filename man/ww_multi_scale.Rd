% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_scale.R
\name{ww_multi_scale}
\alias{ww_multi_scale}
\title{Evaluate metrics at multiple scales of aggregation}
\usage{
ww_multi_scale(
  data,
  truth,
  estimate,
  metrics = list(yardstick::rmse, yardstick::mae),
  grids = NULL,
  ...,
  na_action = na.fail,
  aggregation_function = mean,
  autoexpand_grid = TRUE
)
}
\arguments{
\item{data}{A point geometry \code{sf} object containing the columns specified by
the truth and estimate arguments.}

\item{truth}{The column identifier for the true results
(that is \code{numeric}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:topic-inject]{quasiquotation} (you can unquote column
names). For \verb{_vec()} functions, a \code{numeric} vector.}

\item{estimate}{The column identifier for the predicted
results (that is also \code{numeric}). As with \code{truth} this can be
specified different ways but the primary method is to use an
unquoted variable name. For \verb{_vec()} functions, a \code{numeric} vector.}

\item{metrics}{Either a \code{\link[yardstick:metric_set]{yardstick::metric_set()}} object, or a list of
functions which will be used to construct a \code{\link[yardstick:metric_set]{yardstick::metric_set()}} object
specifying the performance metrics to evaluate at each scale.}

\item{grids}{Optionally, a list of pre-computed \code{sf} or \code{sfc} objects
specifying polygon boundaries to use for assessments.}

\item{...}{Arguments passed to \code{\link[sf:st_make_grid]{sf::st_make_grid()}}.
\strong{You almost certainly should provide these arguments as lists.}
For instance, passing \code{n = list(c(1, 2))} will create a single 1x2 grid;
passing \code{n = c(1, 2)} will create a 1x1 grid \emph{and} a 2x2 grid.}

\item{na_action}{A function which indicates what should happen when the data
contain NAs. The default is \code{na.fail}; you may wish to set it to \code{na.omit}
or any of the functions from the "zoo"
package. This function ignores the value of \code{options("na.action")} in order
to make cross-computer (and cross-session) results more stable. This argument
must be of length 1; you cannot pass multiple functions to \code{na_action}.}

\item{aggregation_function}{The function to use to aggregate predictions and
true values at various scales, by default \code{\link[=mean]{mean()}}. You can pass any function
which takes a single vector and returns a scalar.}

\item{autoexpand_grid}{Boolean: if \code{data} is in geographic coordinates and
\code{grids} aren't provided, the grids generated by \code{\link[sf:st_make_grid]{sf::st_make_grid()}} may not
contain all observations. If \code{TRUE}, this function will automatically expand
generated grids by a tiny factor to attempt to capture all observations.}
}
\value{
A tibble with six columns: \code{.metric}, with the name
of the metric that the row describes; \code{.estimator}, with the name of the
estimator used, \code{.estimate}, with the output of the metric function;
\code{.grid_args}, with the arguments passed to \code{\link[sf:st_make_grid]{sf::st_make_grid()}} via \code{...}
(if any), \code{.grid}, containing the grids used to aggregate predictions,
and \code{.notes}, which will indicate any observations which were not used in
a given assessment.
}
\description{
Evaluate metrics at multiple scales of aggregation
}
\details{
The grid blocks can be controlled by passing arguments to
\code{\link[sf:st_make_grid]{sf::st_make_grid()}} via \code{...}. Some particularly useful arguments include:
\itemize{
\item \code{cellsize}: Target cellsize, expressed as the "diameter" (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
\item \code{n}: The number of grid blocks in the x and y direction (columns, rows).
\item \code{square}: A logical value indicating whether to create square (\code{TRUE}) or
hexagonal (\code{FALSE}) cells.
}

If both \code{cellsize} and \code{n} are provided, then the number of blocks requested
by \code{n} of sizes specified by \code{cellsize} will be returned, likely not
lining up with the bounding box of \code{data}. If only \code{cellsize}
is provided, this function will return as many blocks of size
\code{cellsize} as fit inside the bounding box of \code{data}. If only \code{n} is provided,
then \code{cellsize} will be automatically adjusted to create the requested
number of cells.

This function can be used for geographic or projected coordinate reference
systems and expect 2D data.
}
\examples{
\dontshow{if (rlang::is_installed("modeldata")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
data(ames, package = "modeldata")
ames_sf <- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
ames_model <- lm(Sale_Price ~ Lot_Area, data = ames_sf)
ames_sf$predictions <- predict(ames_model, ames_sf)

ww_multi_scale(
  ames_sf,
  Sale_Price,
  predictions,
  n = list(
    c(20, 20),
    c(10, 10),
    c(1, 1)
  ),
  square = FALSE
)

# or, mostly equivalently
# (there will be a slight difference due to `autoexpand_grid = TRUE`)
grids <- list(
  sf::st_make_grid(ames_sf, n = c(20, 20), square = FALSE),
  sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
  sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
)
ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)
\dontshow{\}) # examplesIf}
}
\references{
Riemann, R., Wilson, B. T., Lister, A., and Parks, S. "An effective
assessment protocol for continuous geospatial datasets of forest
characteristics using USFS Forest Inventory and Analysis (FIA) data."
Remote Sensing of Environment 114(10), pp 2337-2352,
doi: 10.1016/j.rse.2010.05.010 .
}
