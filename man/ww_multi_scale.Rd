% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/multi_scale.R
\name{ww_multi_scale}
\alias{ww_multi_scale}
\title{Evaluate metrics at multiple scales of aggregation}
\usage{
ww_multi_scale(
  data,
  truth,
  estimate,
  metrics = list(yardstick::rmse, yardstick::mae),
  grids = NULL,
  ...,
  na_rm = TRUE,
  aggregation_function = mean,
  autoexpand_grid = TRUE
)
}
\arguments{
\item{data}{A point geometry `sf` object containing the columns specified by
the truth and estimate arguments.}

\item{truth}{The column identifier for the true results
(that is \code{numeric}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:topic-inject]{quasiquotation} (you can unquote column
names). For \verb{_vec()} functions, a \code{numeric} vector.}

\item{estimate}{The column identifier for the predicted
results (that is also \code{numeric}). As with \code{truth} this can be
specified different ways but the primary method is to use an
unquoted variable name. For \verb{_vec()} functions, a \code{numeric} vector.}

\item{metrics}{Either a [yardstick::metric_set()] object, or a list of
functions which will be used to construct a [yardstick::metric_set()] object
specifying the performance metrics to evaluate at each scale.}

\item{grids}{Optionally, a list of pre-computed `sf` or `sfc` objects
specifying polygon boundaries to use for assessments.}

\item{...}{Arguments passed to [sf::st_make_grid()].
**You almost certainly should provide these arguments as lists.**
For instance, passing `n = list(c(1, 2))` will create a single 1x2 grid;
passing `n = c(1, 2)` will create a 1x1 grid _and_ a 2x2 grid.}

\item{na_rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{aggregation_function}{The function to use to aggregate predictions and
true values at various scales, by default [mean()]. You can pass any function
which takes a single vector and returns a scalar.}

\item{autoexpand_grid}{Boolean: if `data` is in geographic coordinates and
`grids` aren't provided, the grids generated by [sf::st_make_grid()] may not
contain all observations. If `TRUE`, this function will automatically expand
generated grids by a tiny factor to attempt to capture all observations.}
}
\value{
A tibble with six columns: `.metric`, with the name
of the metric that the row describes; `.estimator`, with the name of the
estimator used, `.estimate`, with the output of the metric function;
`.grid_args`, with the arguments passed to [sf::st_make_grid()] via `...`
(if any), `.grid`, containing the grids used to aggregate predictions,
and `.notes`, which will indicate any observations which were not used in
a given assessment.
}
\description{
Evaluate metrics at multiple scales of aggregation
}
\details{
The grid blocks can be controlled by passing arguments to
[sf::st_make_grid()] via `...`. Some particularly useful arguments include:

* `cellsize`: Target cellsize, expressed as the "diameter" (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
* `n`: The number of grid blocks in the x and y direction (columns, rows).
* `square`: A logical value indicating whether to create square (`TRUE`) or
hexagonal (`FALSE`) cells.

If both `cellsize` and `n` are provided, then the number of blocks requested
by `n` of sizes specified by `cellsize` will be returned, likely not
lining up with the bounding box of `data`. If only `cellsize`
is provided, this function will return as many blocks of size
`cellsize` as fit inside the bounding box of `data`. If only `n` is provided,
then `cellsize` will be automatically adjusted to create the requested
number of cells.

This function can be used for geographic or projected coordinate reference
systems and expect 2D data.
}
\examples{
\dontshow{if (rlang::is_installed("modeldata")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
data(ames, package = "modeldata")
ames_sf <- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
ames_model <- lm(Sale_Price ~ Lot_Area, data = ames_sf)
ames_sf$predictions <- predict(ames_model, ames_sf)

ww_multi_scale(
  ames_sf,
  Sale_Price,
  predictions,
  n = list(
    c(10, 10),
    c(1, 1)
  ),
  square = FALSE
)

# or, mostly equivalently
# (there will be a slight difference due to `autoexpand_grid = TRUE`)
grids <- list(
  sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
  sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
)
ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)
\dontshow{\}) # examplesIf}
}
\references{
Riemann, R., Wilson, B. T., Lister, A., and Parks, S. (2010). "An effective
assessment protocol for continuous geospatial datasets of forest
characteristics using USFS Forest Inventory and Analysis (FIA) data."
Remote Sensing of Environment 114(10), pp 2337-2352,
doi: 10.1016/j.rse.2010.05.010 .
}
