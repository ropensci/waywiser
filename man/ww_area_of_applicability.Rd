% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/area_of_applicability.R
\name{ww_area_of_applicability}
\alias{ww_area_of_applicability}
\alias{ww_area_of_applicability.data.frame}
\alias{ww_area_of_applicability.matrix}
\alias{ww_area_of_applicability.formula}
\alias{ww_area_of_applicability.recipe}
\alias{ww_area_of_applicability.rset}
\title{Find the area of applicability}
\usage{
ww_area_of_applicability(x, ...)

\method{ww_area_of_applicability}{data.frame}(x, testing = NULL, importance, ...)

\method{ww_area_of_applicability}{matrix}(x, testing = NULL, importance, ...)

\method{ww_area_of_applicability}{formula}(x, data, testing = NULL, importance, ...)

\method{ww_area_of_applicability}{recipe}(x, data, testing = NULL, importance, ...)

\method{ww_area_of_applicability}{rset}(x, y = NULL, importance, ...)
}
\arguments{
\item{x}{Either a data frame, matrix, formula
(specifying predictor terms on the right-hand side), recipe
(from \code{\link[recipes:recipe]{recipes::recipe()}}, or \code{rset} object, produced by resampling functions
from rsample or spatialsample.

If \code{x} is a recipe, it should be the same one used to pre-process the data
used in your model. If the recipe used to build the area of applicability
doesn't match the one used to build the model, the returned area of
applicability won't be correct.}

\item{...}{Not currently used.}

\item{testing}{A data frame or matrix containing the data used to
validate your model. This should be the same data as used to calculate all
model accuracy metrics.

If this argument is \code{NULL}, then this function will use the training data
(from \code{x} or \code{data}) to calculate within-sample distances.
This may result in the area of applicability threshold being set too high,
with the result that too many points are classed as "inside" the area of
applicability.}

\item{importance}{Either:
\itemize{
\item A data.frame with two columns: \code{term}, containing the names of each
variable in the training and testing data, and \code{estimate}, containing
the (raw or scaled) feature importance for each variable.
\item An object of class \code{vi} with at least two columns, \code{Variable} and \code{Importance}.
}

All variables in the training data (\code{x} or \code{data}, depending on the context)
must have a matching importance estimate, and all terms with importance
estimates must be in the training data.}

\item{data}{The data frame representing your "training" data, when using the
formula or recipe methods.}

\item{y}{Optional: a recipe (from \code{\link[recipes:recipe]{recipes::recipe()}}) or formula.

If \code{y} is a recipe, it should be the same one used to pre-process the data
used in your model. If the recipe used to build the area of applicability
doesn't match the one used to build the model, the returned area of
applicability won't be correct.}
}
\value{
A \code{ww_area_of_applicability} object, which can be used with \code{\link[=predict]{predict()}}
to calculate the distance of new data to the original training data, and
determine if new data is within a model's area of applicability.
}
\description{
This function calculates the "area of applicability" of a model, as
introduced by Meyer and Pebesma (2021). While the initial paper introducing
this method focused on spatial models, there is nothing inherently spatial
about the method; it can be used with any type of data.
}
\details{
Predictions made on points "inside" the area of applicability should be as
accurate as predictions made on the data provided to \code{testing}.
That means that generally \code{testing} should be your final hold-out
set so that predictions on points inside the area of applicability are
accurately described by your reported model metrics.
When passing an \code{rset} object to \code{x}, predictions made on points "inside" the
area of applicability instead should be as accurate as predictions made on
the assessment sets during cross-validation.

This method assumes your model was fit using dummy variables in the place of
any non-numeric predictor, and that you have one importance score per
dummy variable. Having non-numeric predictors will cause this function to
fail.
}
\examples{
\dontshow{if (rlang::is_installed("vip")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
train <- vip::gen_friedman(1000, seed = 101)  # ?vip::gen_friedman
test <- train[701:1000, ]
train <- train[1:700, ]
pp <- stats::ppr(y ~ ., data = train, nterms = 11)
importance <- vip::vi_permute(
  pp,
  target = "y",
  metric = "rsquared",
  pred_wrapper = predict
)

ww_area_of_applicability(y ~ ., train, test, importance = importance)
\dontshow{\}) # examplesIf}
}
\references{
H. Meyer and E. Pebesma. 2021. "Predicting into unknown space? Estimating
the area of applicability of spatial prediction models," Methods in Ecology
and Evolution 12(9), pp 1620 - 1633, doi: 10.1111/2041-210X.13650.
}
\seealso{
Other area of applicability functions: 
\code{\link{predict.ww_area_of_applicability}()}
}
\concept{area of applicability functions}
